// ============================================
// MOCK API SERVER
// ============================================

class MockAPI {
  constructor() {
    this.delay = 300; // Simulate network delay
    this.initializeDatabase();
  }

  // Initialize mock database in localStorage
  initializeDatabase() {
    if (!localStorage.getItem('mockDB')) {
      const initialDB = {
        users: [
          {
            id: 1,
            email: 'jan.kowalski@example.com',
            password: 'hash_password123', // In real app - use bcrypt
            name: 'Jan Kowalski',
            avatar: 'JK',
            createdAt: '2024-01-15',
            lastLoginAt: new Date().toISOString(),
            isActive: true,
            preferences: {
              notifications: true,
              darkMode: false,
              language: 'pl'
            }
          }
        ],
        userProgress: [
          {
            userId: 1,
            level: 24,
            xp: 2847,
            xpToNextLevel: 5000,
            coins: 1250,
            gems: 50,
            streak: 7,
            lastActivityDate: new Date().toISOString(),
            totalStudyTime: 4523,
            completedLessons: 127,
            currentPathId: 'frontend'
          }
        ],
        paths: [
          {
            id: 'frontend',
            name: 'Frontend Developer',
            description: 'ZostaÅ„ ekspertem frontend development',
            icon: 'ðŸŽ¨',
            difficulty: 'intermediate',
            estimatedTime: 180, // days
            price: 0,
            isPremium: false,
            tags: ['HTML', 'CSS', 'JavaScript', 'React'],
            requirements: [],
            outcomes: [
              'Tworzenie responsywnych stron',
              'Praca z React i Redux',
              'Optymalizacja wydajnoÅ›ci'
            ]
          },
          {
            id: 'backend',
            name: 'Backend Developer',
            description: 'Opanuj server-side programming',
            icon: 'âš™ï¸',
            difficulty: 'advanced',
            estimatedTime: 240,
            price: 99,
            isPremium: true,
            tags: ['Node.js', 'Python', 'Databases', 'API'],
            requirements: ['frontend'],
            outcomes: [
              'Budowanie REST API',
              'Praca z bazami danych',
              'BezpieczeÅ„stwo aplikacji'
            ]
          }
        ],
        stages: [
          {
            id: 'stage_1',
            pathId: 'frontend',
            order: 1,
            name: 'HTML/CSS',
            description: 'Podstawy tworzenia stron',
            icon: 'ðŸŽ¯',
            requiredXP: 500,
            lessons: ['lesson_1', 'lesson_2', 'lesson_3']
          },
          {
            id: 'stage_2',
            pathId: 'frontend',
            order: 2,
            name: 'JavaScript',
            description: 'Programowanie w JavaScript',
            icon: 'âš¡',
            requiredXP: 750,
            lessons: ['lesson_4', 'lesson_5', 'lesson_6']
          }
        ],
        lessons: [
          {
            id: 'lesson_1',
            stageId: 'stage_1',
            name: 'Wprowadzenie do HTML',
            type: 'video',
            duration: 15,
            xpReward: 50,
            content: {
              videoUrl: 'https://example.com/video1',
              materials: ['html_basics.pdf'],
              quiz: ['quiz_1']
            }
          },
          {
            id: 'lesson_2',
            stageId: 'stage_1',
            name: 'CSS Podstawy',
            type: 'interactive',
            duration: 20,
            xpReward: 75,
            content: {
              exercises: ['exercise_1', 'exercise_2'],
              quiz: ['quiz_2']
            }
          }
        ],
        userStageProgress: [
          {
            userId: 1,
            stageId: 'stage_1',
            status: 'completed',
            xpEarned: 500,
            completedAt: '2024-02-01',
            lessonsCompleted: ['lesson_1', 'lesson_2', 'lesson_3']
          },
          {
            userId: 1,
            stageId: 'stage_2',
            status: 'in_progress',
            xpEarned: 340,
            startedAt: '2024-02-15',
            lessonsCompleted: ['lesson_4']
          }
        ],
        achievements: [
          {
            id: 'first_week',
            name: 'Pierwszy TydzieÅ„',
            description: 'UkoÅ„cz pierwszy tydzieÅ„ nauki',
            icon: 'ðŸ”¥',
            xpReward: 100,
            coinReward: 50,
            rarity: 'common',
            criteria: {
              type: 'streak',
              value: 7
            }
          },
          {
            id: 'speed_demon',
            name: 'Speed Demon',
            description: 'UkoÅ„cz 5 lekcji w jeden dzieÅ„',
            icon: 'âš¡',
            xpReward: 200,
            coinReward: 100,
            rarity: 'rare',
            criteria: {
              type: 'daily_lessons',
              value: 5
            }
          }
        ],
        userAchievements: [
          {
            userId: 1,
            achievementId: 'first_week',
            unlockedAt: '2024-01-22',
            level: 3
          },
          {
            userId: 1,
            achievementId: 'speed_demon',
            unlockedAt: '2024-02-10',
            level: 2
          }
        ],
        dailyChallenges: [
          {
            id: 'daily_1',
            date: new Date().toISOString().split('T')[0],
            name: 'UkoÅ„cz 3 lekcje',
            type: 'lessons',
            target: 3,
            xpReward: 100,
            coinReward: 50
          },
          {
            id: 'daily_2',
            date: new Date().toISOString().split('T')[0],
            name: 'ZdobÄ…dÅº 500 XP',
            type: 'xp',
            target: 500,
            xpReward: 50,
            coinReward: 25
          }
        ],
        userDailyChallenges: [
          {
            userId: 1,
            challengeId: 'daily_1',
            date: new Date().toISOString().split('T')[0],
            progress: 2,
            completed: false
          },
          {
            userId: 1,
            challengeId: 'daily_2',
            date: new Date().toISOString().split('T')[0],
            progress: 340,
            completed: false
          }
        ],
        competitions: [
          {
            id: 'comp_1',
            name: 'JavaScript Masters',
            description: 'Konkurencja w JavaScript',
            startDate: '2024-03-01',
            endDate: '2024-03-07',
            prize: {
              type: 'cash',
              value: 1000,
              currency: 'PLN'
            },
            entryFee: 0,
            maxParticipants: 500,
            rules: ['Max 3 prÃ³by', 'Czas: 60 minut'],
            status: 'active'
          }
        ],
        competitionParticipants: [
          {
            competitionId: 'comp_1',
            userId: 1,
            score: 850,
            rank: 12,
            attempts: 2,
            bestTime: 45,
            joinedAt: '2024-03-02'
          }
        ],
        leaderboard: [
          {
            userId: 1,
            weeklyXP: 2847,
            monthlyXP: 8543,
            allTimeXP: 45230,
            weeklyRank: 24,
            monthlyRank: 156,
            allTimeRank: 892
          }
        ],
        shopItems: [
          {
            id: 'item_1',
            name: 'XP Boost 2x',
            description: '30 minut podwÃ³jnego XP',
            type: 'boost',
            price: 500,
            currency: 'coins',
            duration: 30,
            icon: 'âš¡',
            isActive: true,
            isPremium: false
          },
          {
            id: 'item_2',
            name: 'Streak Freeze',
            description: 'Zachowaj seriÄ™ przez 1 dzieÅ„',
            type: 'protection',
            price: 750,
            currency: 'coins',
            duration: 1,
            icon: 'ðŸ§Š',
            isActive: true,
            isPremium: false
          }
        ],
        userInventory: [
          {
            userId: 1,
            itemId: 'item_1',
            quantity: 2,
            purchasedAt: '2024-03-01',
            expiresAt: null
          }
        ],
        notifications: [
          {
            id: 'notif_1',
            userId: 1,
            type: 'achievement',
            title: 'Nowa odznaka!',
            message: 'ZdobyÅ‚eÅ› odznakÄ™ Speed Demon',
            data: { achievementId: 'speed_demon' },
            createdAt: new Date().toISOString(),
            readAt: null
          }
        ],
        friendships: [
          {
            userId1: 1,
            userId2: 2,
            status: 'accepted',
            createdAt: '2024-02-01'
          }
        ],
        studySessions: [
          {
            userId: 1,
            lessonId: 'lesson_1',
            startedAt: '2024-03-01T10:00:00',
            endedAt: '2024-03-01T10:15:00',
            xpEarned: 50,
            completed: true
          }
        ]
      };
      
      localStorage.setItem('mockDB', JSON.stringify(initialDB));
    }
  }

  // Helper to simulate async operations
  async simulateDelay() {
    return new Promise(resolve => setTimeout(resolve, this.delay));
  }

  // Get database
  getDB() {
    return JSON.parse(localStorage.getItem('mockDB') || '{}');
  }

  // Save database
  saveDB(db) {
    localStorage.setItem('mockDB', JSON.stringify(db));
  }

  // ============================================
  // AUTH ENDPOINTS
  // ============================================

  async login(email, password) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const user = db.users.find(u => u.email === email);
    if (!user) {
      throw new Error('User not found');
    }
    
    // In real app, compare hashed passwords
    if (user.password !== `hash_${password}`) {
      throw new Error('Invalid password');
    }
    
    // Update last login
    user.lastLoginAt = new Date().toISOString();
    this.saveDB(db);
    
    // Generate token (in real app, use JWT)
    const token = btoa(JSON.stringify({ userId: user.id, exp: Date.now() + 86400000 }));
    
    return {
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar
      }
    };
  }

  async register(email, password, name) {
    await this.simulateDelay();
    const db = this.getDB();
    
    // Check if user exists
    if (db.users.find(u => u.email === email)) {
      throw new Error('User already exists');
    }
    
    // Create new user
    const newUser = {
      id: db.users.length + 1,
      email,
      password: `hash_${password}`,
      name,
      avatar: name.split(' ').map(n => n[0]).join('').toUpperCase(),
      createdAt: new Date().toISOString(),
      lastLoginAt: new Date().toISOString(),
      isActive: true,
      preferences: {
        notifications: true,
        darkMode: false,
        language: 'pl'
      }
    };
    
    // Create initial progress
    const newProgress = {
      userId: newUser.id,
      level: 1,
      xp: 0,
      xpToNextLevel: 1000,
      coins: 100, // Welcome bonus
      gems: 5,
      streak: 0,
      lastActivityDate: new Date().toISOString(),
      totalStudyTime: 0,
      completedLessons: 0,
      currentPathId: null
    };
    
    db.users.push(newUser);
    db.userProgress.push(newProgress);
    this.saveDB(db);
    
    const token = btoa(JSON.stringify({ userId: newUser.id, exp: Date.now() + 86400000 }));
    
    return { token, user: newUser };
  }

  // ============================================
  // USER ENDPOINTS
  // ============================================

  async getUserProgress(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const progress = db.userProgress.find(p => p.userId === userId);
    if (!progress) {
      throw new Error('Progress not found');
    }
    
    return progress;
  }

  async updateUserProgress(userId, updates) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const progressIndex = db.userProgress.findIndex(p => p.userId === userId);
    if (progressIndex === -1) {
      throw new Error('Progress not found');
    }
    
    db.userProgress[progressIndex] = {
      ...db.userProgress[progressIndex],
      ...updates,
      lastActivityDate: new Date().toISOString()
    };
    
    this.saveDB(db);
    return db.userProgress[progressIndex];
  }

  // ============================================
  // LEARNING ENDPOINTS
  // ============================================

  async getPaths() {
    await this.simulateDelay();
    const db = this.getDB();
    return db.paths;
  }

  async getPathDetails(pathId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const path = db.paths.find(p => p.id === pathId);
    if (!path) {
      throw new Error('Path not found');
    }
    
    const stages = db.stages.filter(s => s.pathId === pathId).sort((a, b) => a.order - b.order);
    
    return { ...path, stages };
  }

  async getLessons(stageId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.lessons.filter(l => l.stageId === stageId);
  }

  async completeLesson(userId, lessonId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const lesson = db.lessons.find(l => l.id === lessonId);
    if (!lesson) {
      throw new Error('Lesson not found');
    }
    
    // Update user progress
    const userProgress = db.userProgress.find(p => p.userId === userId);
    if (!userProgress) {
      throw new Error('User progress not found');
    }
    
    // Add XP
    userProgress.xp += lesson.xpReward;
    userProgress.completedLessons += 1;
    
    // Check for level up
    if (userProgress.xp >= userProgress.xpToNextLevel) {
      userProgress.level += 1;
      userProgress.xp -= userProgress.xpToNextLevel;
      userProgress.xpToNextLevel = Math.floor(userProgress.xpToNextLevel * 1.2);
    }
    
    // Record study session
    db.studySessions.push({
      userId,
      lessonId,
      startedAt: new Date(Date.now() - lesson.duration * 60000).toISOString(),
      endedAt: new Date().toISOString(),
      xpEarned: lesson.xpReward,
      completed: true
    });
    
    // Update stage progress
    const stage = db.stages.find(s => s.id === lesson.stageId);
    let stageProgress = db.userStageProgress.find(
      sp => sp.userId === userId && sp.stageId === lesson.stageId
    );
    
    if (!stageProgress) {
      stageProgress = {
        userId,
        stageId: lesson.stageId,
        status: 'in_progress',
        xpEarned: 0,
        startedAt: new Date().toISOString(),
        lessonsCompleted: []
      };
      db.userStageProgress.push(stageProgress);
    }
    
    if (!stageProgress.lessonsCompleted.includes(lessonId)) {
      stageProgress.lessonsCompleted.push(lessonId);
      stageProgress.xpEarned += lesson.xpReward;
    }
    
    // Check if stage is completed
    if (stageProgress.xpEarned >= stage.requiredXP) {
      stageProgress.status = 'completed';
      stageProgress.completedAt = new Date().toISOString();
    }
    
    this.saveDB(db);
    
    return {
      xpEarned: lesson.xpReward,
      newLevel: userProgress.level,
      totalXP: userProgress.xp,
      stageCompleted: stageProgress.status === 'completed'
    };
  }

  // ============================================
  // GAMIFICATION ENDPOINTS
  // ============================================

  async getDailyChallenges(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const today = new Date().toISOString().split('T')[0];
    const challenges = db.dailyChallenges.filter(c => c.date === today);
    const userChallenges = db.userDailyChallenges.filter(
      uc => uc.userId === userId && uc.date === today
    );
    
    return challenges.map(challenge => {
      const userChallenge = userChallenges.find(uc => uc.challengeId === challenge.id);
      return {
        ...challenge,
        progress: userChallenge?.progress || 0,
        completed: userChallenge?.completed || false
      };
    });
  }

  async updateChallengeProgress(userId, challengeId, progress) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const challenge = db.dailyChallenges.find(c => c.id === challengeId);
    if (!challenge) {
      throw new Error('Challenge not found');
    }
    
    let userChallenge = db.userDailyChallenges.find(
      uc => uc.userId === userId && uc.challengeId === challengeId
    );
    
    if (!userChallenge) {
      userChallenge = {
        userId,
        challengeId,
        date: new Date().toISOString().split('T')[0],
        progress: 0,
        completed: false
      };
      db.userDailyChallenges.push(userChallenge);
    }
    
    userChallenge.progress = Math.min(progress, challenge.target);
    
    // Check if completed
    if (userChallenge.progress >= challenge.target && !userChallenge.completed) {
      userChallenge.completed = true;
      
      // Award rewards
      const userProgress = db.userProgress.find(p => p.userId === userId);
      userProgress.xp += challenge.xpReward;
      userProgress.coins += challenge.coinReward;
      
      // Create notification
      db.notifications.push({
        id: `notif_${Date.now()}`,
        userId,
        type: 'challenge',
        title: 'Wyzwanie ukoÅ„czone!',
        message: `UkoÅ„czyÅ‚eÅ› wyzwanie "${challenge.name}" i zdobyÅ‚eÅ› ${challenge.coinReward} monet!`,
        data: { challengeId },
        createdAt: new Date().toISOString(),
        readAt: null
      });
    }
    
    this.saveDB(db);
    return userChallenge;
  }

  async getAchievements(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const userAchievements = db.userAchievements.filter(ua => ua.userId === userId);
    
    return db.achievements.map(achievement => {
      const userAchievement = userAchievements.find(ua => ua.achievementId === achievement.id);
      return {
        ...achievement,
        unlocked: !!userAchievement,
        unlockedAt: userAchievement?.unlockedAt,
        level: userAchievement?.level || 0
      };
    });
  }

  async checkAndUnlockAchievements(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const userProgress = db.userProgress.find(p => p.userId === userId);
    const unlockedAchievements = [];
    
    for (const achievement of db.achievements) {
      const alreadyUnlocked = db.userAchievements.find(
        ua => ua.userId === userId && ua.achievementId === achievement.id
      );
      
      if (!alreadyUnlocked) {
        let shouldUnlock = false;
        
        // Check criteria
        switch (achievement.criteria.type) {
          case 'streak':
            shouldUnlock = userProgress.streak >= achievement.criteria.value;
            break;
          case 'level':
            shouldUnlock = userProgress.level >= achievement.criteria.value;
            break;
          case 'lessons':
            shouldUnlock = userProgress.completedLessons >= achievement.criteria.value;
            break;
        }
        
        if (shouldUnlock) {
          db.userAchievements.push({
            userId,
            achievementId: achievement.id,
            unlockedAt: new Date().toISOString(),
            level: 1
          });
          
          // Award rewards
          userProgress.xp += achievement.xpReward;
          userProgress.coins += achievement.coinReward;
          
          // Create notification
          db.notifications.push({
            id: `notif_${Date.now()}`,
            userId,
            type: 'achievement',
            title: 'Nowa odznaka!',
            message: `ZdobyÅ‚eÅ› odznakÄ™ "${achievement.name}"!`,
            data: { achievementId: achievement.id },
            createdAt: new Date().toISOString(),
            readAt: null
          });
          
          unlockedAchievements.push(achievement);
        }
      }
    }
    
    this.saveDB(db);
    return unlockedAchievements;
  }

  // ============================================
  // COMPETITION ENDPOINTS
  // ============================================

  async getCompetitions() {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.competitions.filter(c => c.status === 'active');
  }

  async joinCompetition(userId, competitionId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const competition = db.competitions.find(c => c.id === competitionId);
    if (!competition) {
      throw new Error('Competition not found');
    }
    
    const existingParticipant = db.competitionParticipants.find(
      cp => cp.userId === userId && cp.competitionId === competitionId
    );
    
    if (existingParticipant) {
      throw new Error('Already participating');
    }
    
    const participant = {
      competitionId,
      userId,
      score: 0,
      rank: null,
      attempts: 0,
      bestTime: null,
      joinedAt: new Date().toISOString()
    };
    
    db.competitionParticipants.push(participant);
    this.saveDB(db);
    
    return participant;
  }

  async getLeaderboard(type = 'weekly') {
    await this.simulateDelay();
    const db = this.getDB();
    
    const leaderboard = db.leaderboard.sort((a, b) => {
      switch (type) {
        case 'weekly':
          return b.weeklyXP - a.weeklyXP;
        case 'monthly':
          return b.monthlyXP - a.monthlyXP;
        case 'allTime':
          return b.allTimeXP - a.allTimeXP;
        default:
          return 0;
      }
    });
    
    // Add user details
    return leaderboard.map(entry => {
      const user = db.users.find(u => u.id === entry.userId);
      return {
        ...entry,
        name: user?.name,
        avatar: user?.avatar
      };
    });
  }

  // ============================================
  // SHOP ENDPOINTS
  // ============================================

  async getShopItems() {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.shopItems.filter(item => item.isActive);
  }

  async purchaseItem(userId, itemId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const item = db.shopItems.find(i => i.id === itemId);
    if (!item) {
      throw new Error('Item not found');
    }
    
    const userProgress = db.userProgress.find(p => p.userId === userId);
    
    // Check currency
    if (item.currency === 'coins' && userProgress.coins < item.price) {
      throw new Error('Insufficient coins');
    }
    if (item.currency === 'gems' && userProgress.gems < item.price) {
      throw new Error('Insufficient gems');
    }
    
    // Deduct currency
    if (item.currency === 'coins') {
      userProgress.coins -= item.price;
    } else {
      userProgress.gems -= item.price;
    }
    
    // Add to inventory
    let inventoryItem = db.userInventory.find(
      inv => inv.userId === userId && inv.itemId === itemId
    );
    
    if (inventoryItem) {
      inventoryItem.quantity += 1;
    } else {
      db.userInventory.push({
        userId,
        itemId,
        quantity: 1,
        purchasedAt: new Date().toISOString(),
        expiresAt: item.duration ? new Date(Date.now() + item.duration * 86400000).toISOString() : null
      });
    }
    
    this.saveDB(db);
    
    return {
      success: true,
      newBalance: {
        coins: userProgress.coins,
        gems: userProgress.gems
      }
    };
  }

  async getUserInventory(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const inventory = db.userInventory.filter(inv => inv.userId === userId);
    
    return inventory.map(inv => {
      const item = db.shopItems.find(i => i.id === inv.itemId);
      return {
        ...inv,
        item
      };
    });
  }

  async useItem(userId, itemId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const inventoryItem = db.userInventory.find(
      inv => inv.userId === userId && inv.itemId === itemId && inv.quantity > 0
    );
    
    if (!inventoryItem) {
      throw new Error('Item not found in inventory');
    }
    
    const item = db.shopItems.find(i => i.id === itemId);
    
    // Apply item effect
    const userProgress = db.userProgress.find(p => p.userId === userId);
    
    switch (item.type) {
      case 'boost':
        // In real app, set boost expiration time
        userProgress.activeBoosts = userProgress.activeBoosts || [];
        userProgress.activeBoosts.push({
          type: 'xp_multiplier',
          value: 2,
          expiresAt: new Date(Date.now() + item.duration * 60000).toISOString()
        });
        break;
      case 'protection':
        // Streak freeze
        userProgress.streakFreezeActive = true;
        userProgress.streakFreezeExpires = new Date(Date.now() + 86400000).toISOString();
        break;
    }
    
    // Reduce quantity
    inventoryItem.quantity -= 1;
    
    this.saveDB(db);
    
    return {
      success: true,
      effect: item.type,
      duration: item.duration
    };
  }

  // ============================================
  // SOCIAL ENDPOINTS
  // ============================================

  async getFriends(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const friendships = db.friendships.filter(
      f => (f.userId1 === userId || f.userId2 === userId) && f.status === 'accepted'
    );
    
    const friendIds = friendships.map(f => 
      f.userId1 === userId ? f.userId2 : f.userId1
    );
    
    const friends = friendIds.map(friendId => {
      const user = db.users.find(u => u.id === friendId);
      const progress = db.userProgress.find(p => p.userId === friendId);
      
      return {
        id: user.id,
        name: user.name,
        avatar: user.avatar,
        level: progress?.level,
        xp: progress?.xp,
        streak: progress?.streak,
        isOnline: Math.random() > 0.5 // Simulate online status
      };
    });
    
    return friends;
  }

  async sendFriendRequest(userId, friendEmail





// ============================================
// MOCK API SERVER
// ============================================

class MockAPI {
  constructor() {
    this.delay = 300; // Simulate network delay
    this.initializeDatabase();
  }

  // Initialize mock database in localStorage
  initializeDatabase() {
    if (!localStorage.getItem('mockDB')) {
      const initialDB = {
        users: [
          {
            id: 1,
            email: 'jan.kowalski@example.com',
            password: 'hash_password123', // In real app - use bcrypt
            name: 'Jan Kowalski',
            avatar: 'JK',
            createdAt: '2024-01-15',
            lastLoginAt: new Date().toISOString(),
            isActive: true,
            preferences: {
              notifications: true,
              darkMode: false,
              language: 'pl'
            }
          }
        ],
        userProgress: [
          {
            userId: 1,
            level: 24,
            xp: 2847,
            xpToNextLevel: 5000,
            coins: 1250,
            gems: 50,
            streak: 7,
            lastActivityDate: new Date().toISOString(),
            totalStudyTime: 4523,
            completedLessons: 127,
            currentPathId: 'frontend'
          }
        ],
        paths: [
          {
            id: 'frontend',
            name: 'Frontend Developer',
            description: 'ZostaÅ„ ekspertem frontend development',
            icon: 'ðŸŽ¨',
            difficulty: 'intermediate',
            estimatedTime: 180, // days
            price: 0,
            isPremium: false,
            tags: ['HTML', 'CSS', 'JavaScript', 'React'],
            requirements: [],
            outcomes: [
              'Tworzenie responsywnych stron',
              'Praca z React i Redux',
              'Optymalizacja wydajnoÅ›ci'
            ]
          },
          {
            id: 'backend',
            name: 'Backend Developer',
            description: 'Opanuj server-side programming',
            icon: 'âš™ï¸',
            difficulty: 'advanced',
            estimatedTime: 240,
            price: 99,
            isPremium: true,
            tags: ['Node.js', 'Python', 'Databases', 'API'],
            requirements: ['frontend'],
            outcomes: [
              'Budowanie REST API',
              'Praca z bazami danych',
              'BezpieczeÅ„stwo aplikacji'
            ]
          }
        ],
        stages: [
          {
            id: 'stage_1',
            pathId: 'frontend',
            order: 1,
            name: 'HTML/CSS',
            description: 'Podstawy tworzenia stron',
            icon: 'ðŸŽ¯',
            requiredXP: 500,
            lessons: ['lesson_1', 'lesson_2', 'lesson_3']
          },
          {
            id: 'stage_2',
            pathId: 'frontend',
            order: 2,
            name: 'JavaScript',
            description: 'Programowanie w JavaScript',
            icon: 'âš¡',
            requiredXP: 750,
            lessons: ['lesson_4', 'lesson_5', 'lesson_6']
          }
        ],
        lessons: [
          {
            id: 'lesson_1',
            stageId: 'stage_1',
            name: 'Wprowadzenie do HTML',
            type: 'video',
            duration: 15,
            xpReward: 50,
            content: {
              videoUrl: 'https://example.com/video1',
              materials: ['html_basics.pdf'],
              quiz: ['quiz_1']
            }
          },
          {
            id: 'lesson_2',
            stageId: 'stage_1',
            name: 'CSS Podstawy',
            type: 'interactive',
            duration: 20,
            xpReward: 75,
            content: {
              exercises: ['exercise_1', 'exercise_2'],
              quiz: ['quiz_2']
            }
          }
        ],
        userStageProgress: [
          {
            userId: 1,
            stageId: 'stage_1',
            status: 'completed',
            xpEarned: 500,
            completedAt: '2024-02-01',
            lessonsCompleted: ['lesson_1', 'lesson_2', 'lesson_3']
          },
          {
            userId: 1,
            stageId: 'stage_2',
            status: 'in_progress',
            xpEarned: 340,
            startedAt: '2024-02-15',
            lessonsCompleted: ['lesson_4']
          }
        ],
        achievements: [
          {
            id: 'first_week',
            name: 'Pierwszy TydzieÅ„',
            description: 'UkoÅ„cz pierwszy tydzieÅ„ nauki',
            icon: 'ðŸ”¥',
            xpReward: 100,
            coinReward: 50,
            rarity: 'common',
            criteria: {
              type: 'streak',
              value: 7
            }
          },
          {
            id: 'speed_demon',
            name: 'Speed Demon',
            description: 'UkoÅ„cz 5 lekcji w jeden dzieÅ„',
            icon: 'âš¡',
            xpReward: 200,
            coinReward: 100,
            rarity: 'rare',
            criteria: {
              type: 'daily_lessons',
              value: 5
            }
          }
        ],
        userAchievements: [
          {
            userId: 1,
            achievementId: 'first_week',
            unlockedAt: '2024-01-22',
            level: 3
          },
          {
            userId: 1,
            achievementId: 'speed_demon',
            unlockedAt: '2024-02-10',
            level: 2
          }
        ],
        dailyChallenges: [
          {
            id: 'daily_1',
            date: new Date().toISOString().split('T')[0],
            name: 'UkoÅ„cz 3 lekcje',
            type: 'lessons',
            target: 3,
            xpReward: 100,
            coinReward: 50
          },
          {
            id: 'daily_2',
            date: new Date().toISOString().split('T')[0],
            name: 'ZdobÄ…dÅº 500 XP',
            type: 'xp',
            target: 500,
            xpReward: 50,
            coinReward: 25
          }
        ],
        userDailyChallenges: [
          {
            userId: 1,
            challengeId: 'daily_1',
            date: new Date().toISOString().split('T')[0],
            progress: 2,
            completed: false
          },
          {
            userId: 1,
            challengeId: 'daily_2',
            date: new Date().toISOString().split('T')[0],
            progress: 340,
            completed: false
          }
        ],
        competitions: [
          {
            id: 'comp_1',
            name: 'JavaScript Masters',
            description: 'Konkurencja w JavaScript',
            startDate: '2024-03-01',
            endDate: '2024-03-07',
            prize: {
              type: 'cash',
              value: 1000,
              currency: 'PLN'
            },
            entryFee: 0,
            maxParticipants: 500,
            rules: ['Max 3 prÃ³by', 'Czas: 60 minut'],
            status: 'active'
          }
        ],
        competitionParticipants: [
          {
            competitionId: 'comp_1',
            userId: 1,
            score: 850,
            rank: 12,
            attempts: 2,
            bestTime: 45,
            joinedAt: '2024-03-02'
          }
        ],
        leaderboard: [
          {
            userId: 1,
            weeklyXP: 2847,
            monthlyXP: 8543,
            allTimeXP: 45230,
            weeklyRank: 24,
            monthlyRank: 156,
            allTimeRank: 892
          }
        ],
        shopItems: [
          {
            id: 'item_1',
            name: 'XP Boost 2x',
            description: '30 minut podwÃ³jnego XP',
            type: 'boost',
            price: 500,
            currency: 'coins',
            duration: 30,
            icon: 'âš¡',
            isActive: true,
            isPremium: false
          },
          {
            id: 'item_2',
            name: 'Streak Freeze',
            description: 'Zachowaj seriÄ™ przez 1 dzieÅ„',
            type: 'protection',
            price: 750,
            currency: 'coins',
            duration: 1,
            icon: 'ðŸ§Š',
            isActive: true,
            isPremium: false
          }
        ],
        userInventory: [
          {
            userId: 1,
            itemId: 'item_1',
            quantity: 2,
            purchasedAt: '2024-03-01',
            expiresAt: null
          }
        ],
        notifications: [
          {
            id: 'notif_1',
            userId: 1,
            type: 'achievement',
            title: 'Nowa odznaka!',
            message: 'ZdobyÅ‚eÅ› odznakÄ™ Speed Demon',
            data: { achievementId: 'speed_demon' },
            createdAt: new Date().toISOString(),
            readAt: null
          }
        ],
        friendships: [
          {
            userId1: 1,
            userId2: 2,
            status: 'accepted',
            createdAt: '2024-02-01'
          }
        ],
        studySessions: [
          {
            userId: 1,
            lessonId: 'lesson_1',
            startedAt: '2024-03-01T10:00:00',
            endedAt: '2024-03-01T10:15:00',
            xpEarned: 50,
            completed: true
          }
        ]
      };
      
      localStorage.setItem('mockDB', JSON.stringify(initialDB));
    }
  }

  // Helper to simulate async operations
  async simulateDelay() {
    return new Promise(resolve => setTimeout(resolve, this.delay));
  }

  // Get database
  getDB() {
    return JSON.parse(localStorage.getItem('mockDB') || '{}');
  }

  // Save database
  saveDB(db) {
    localStorage.setItem('mockDB', JSON.stringify(db));
  }

  // ============================================
  // AUTH ENDPOINTS
  // ============================================

  async login(email, password) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const user = db.users.find(u => u.email === email);
    if (!user) {
      throw new Error('User not found');
    }
    
    // In real app, compare hashed passwords
    if (user.password !== `hash_${password}`) {
      throw new Error('Invalid password');
    }
    
    // Update last login
    user.lastLoginAt = new Date().toISOString();
    this.saveDB(db);
    
    // Generate token (in real app, use JWT)
    const token = btoa(JSON.stringify({ userId: user.id, exp: Date.now() + 86400000 }));
    
    return {
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar
      }
    };
  }

  async register(email, password, name) {
    await this.simulateDelay();
    const db = this.getDB();
    
    // Check if user exists
    if (db.users.find(u => u.email === email)) {
      throw new Error('User already exists');
    }
    
    // Create new user
    const newUser = {
      id: db.users.length + 1,
      email,
      password: `hash_${password}`,
      name,
      avatar: name.split(' ').map(n => n[0]).join('').toUpperCase(),
      createdAt: new Date().toISOString(),
      lastLoginAt: new Date().toISOString(),
      isActive: true,
      preferences: {
        notifications: true,
        darkMode: false,
        language: 'pl'
      }
    };
    
    // Create initial progress
    const newProgress = {
      userId: newUser.id,
      level: 1,
      xp: 0,
      xpToNextLevel: 1000,
      coins: 100, // Welcome bonus
      gems: 5,
      streak: 0,
      lastActivityDate: new Date().toISOString(),
      totalStudyTime: 0,
      completedLessons: 0,
      currentPathId: null
    };
    
    db.users.push(newUser);
    db.userProgress.push(newProgress);
    this.saveDB(db);
    
    const token = btoa(JSON.stringify({ userId: newUser.id, exp: Date.now() + 86400000 }));
    
    return { token, user: newUser };
  }

  // ============================================
  // USER ENDPOINTS
  // ============================================

  async getUserProgress(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const progress = db.userProgress.find(p => p.userId === userId);
    if (!progress) {
      throw new Error('Progress not found');
    }
    
    return progress;
  }

  async updateUserProgress(userId, updates) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const progressIndex = db.userProgress.findIndex(p => p.userId === userId);
    if (progressIndex === -1) {
      throw new Error('Progress not found');
    }
    
    db.userProgress[progressIndex] = {
      ...db.userProgress[progressIndex],
      ...updates,
      lastActivityDate: new Date().toISOString()
    };
    
    this.saveDB(db);
    return db.userProgress[progressIndex];
  }

  // ============================================
  // LEARNING ENDPOINTS
  // ============================================

  async getPaths() {
    await this.simulateDelay();
    const db = this.getDB();
    return db.paths;
  }

  async getPathDetails(pathId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const path = db.paths.find(p => p.id === pathId);
    if (!path) {
      throw new Error('Path not found');
    }
    
    const stages = db.stages.filter(s => s.pathId === pathId).sort((a, b) => a.order - b.order);
    
    return { ...path, stages };
  }

  async getLessons(stageId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.lessons.filter(l => l.stageId === stageId);
  }

  async completeLesson(userId, lessonId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const lesson = db.lessons.find(l => l.id === lessonId);
    if (!lesson) {
      throw new Error('Lesson not found');
    }
    
    // Update user progress
    const userProgress = db.userProgress.find(p => p.userId === userId);
    if (!userProgress) {
      throw new Error('User progress not found');
    }
    
    // Add XP
    userProgress.xp += lesson.xpReward;
    userProgress.completedLessons += 1;
    
    // Check for level up
    if (userProgress.xp >= userProgress.xpToNextLevel) {
      userProgress.level += 1;
      userProgress.xp -= userProgress.xpToNextLevel;
      userProgress.xpToNextLevel = Math.floor(userProgress.xpToNextLevel * 1.2);
    }
    
    // Record study session
    db.studySessions.push({
      userId,
      lessonId,
      startedAt: new Date(Date.now() - lesson.duration * 60000).toISOString(),
      endedAt: new Date().toISOString(),
      xpEarned: lesson.xpReward,
      completed: true
    });
    
    // Update stage progress
    const stage = db.stages.find(s => s.id === lesson.stageId);
    let stageProgress = db.userStageProgress.find(
      sp => sp.userId === userId && sp.stageId === lesson.stageId
    );
    
    if (!stageProgress) {
      stageProgress = {
        userId,
        stageId: lesson.stageId,
        status: 'in_progress',
        xpEarned: 0,
        startedAt: new Date().toISOString(),
        lessonsCompleted: []
      };
      db.userStageProgress.push(stageProgress);
    }
    
    if (!stageProgress.lessonsCompleted.includes(lessonId)) {
      stageProgress.lessonsCompleted.push(lessonId);
      stageProgress.xpEarned += lesson.xpReward;
    }
    
    // Check if stage is completed
    if (stageProgress.xpEarned >= stage.requiredXP) {
      stageProgress.status = 'completed';
      stageProgress.completedAt = new Date().toISOString();
    }
    
    this.saveDB(db);
    
    return {
      xpEarned: lesson.xpReward,
      newLevel: userProgress.level,
      totalXP: userProgress.xp,
      stageCompleted: stageProgress.status === 'completed'
    };
  }

  // ============================================
  // GAMIFICATION ENDPOINTS
  // ============================================

  async getDailyChallenges(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const today = new Date().toISOString().split('T')[0];
    const challenges = db.dailyChallenges.filter(c => c.date === today);
    const userChallenges = db.userDailyChallenges.filter(
      uc => uc.userId === userId && uc.date === today
    );
    
    return challenges.map(challenge => {
      const userChallenge = userChallenges.find(uc => uc.challengeId === challenge.id);
      return {
        ...challenge,
        progress: userChallenge?.progress || 0,
        completed: userChallenge?.completed || false
      };
    });
  }

  async updateChallengeProgress(userId, challengeId, progress) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const challenge = db.dailyChallenges.find(c => c.id === challengeId);
    if (!challenge) {
      throw new Error('Challenge not found');
    }
    
    let userChallenge = db.userDailyChallenges.find(
      uc => uc.userId === userId && uc.challengeId === challengeId
    );
    
    if (!userChallenge) {
      userChallenge = {
        userId,
        challengeId,
        date: new Date().toISOString().split('T')[0],
        progress: 0,
        completed: false
      };
      db.userDailyChallenges.push(userChallenge);
    }
    
    userChallenge.progress = Math.min(progress, challenge.target);
    
    // Check if completed
    if (userChallenge.progress >= challenge.target && !userChallenge.completed) {
      userChallenge.completed = true;
      
      // Award rewards
      const userProgress = db.userProgress.find(p => p.userId === userId);
      userProgress.xp += challenge.xpReward;
      userProgress.coins += challenge.coinReward;
      
      // Create notification
      db.notifications.push({
        id: `notif_${Date.now()}`,
        userId,
        type: 'challenge',
        title: 'Wyzwanie ukoÅ„czone!',
        message: `UkoÅ„czyÅ‚eÅ› wyzwanie "${challenge.name}" i zdobyÅ‚eÅ› ${challenge.coinReward} monet!`,
        data: { challengeId },
        createdAt: new Date().toISOString(),
        readAt: null
      });
    }
    
    this.saveDB(db);
    return userChallenge;
  }

  async getAchievements(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const userAchievements = db.userAchievements.filter(ua => ua.userId === userId);
    
    return db.achievements.map(achievement => {
      const userAchievement = userAchievements.find(ua => ua.achievementId === achievement.id);
      return {
        ...achievement,
        unlocked: !!userAchievement,
        unlockedAt: userAchievement?.unlockedAt,
        level: userAchievement?.level || 0
      };
    });
  }

  async checkAndUnlockAchievements(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const userProgress = db.userProgress.find(p => p.userId === userId);
    const unlockedAchievements = [];
    
    for (const achievement of db.achievements) {
      const alreadyUnlocked = db.userAchievements.find(
        ua => ua.userId === userId && ua.achievementId === achievement.id
      );
      
      if (!alreadyUnlocked) {
        let shouldUnlock = false;
        
        // Check criteria
        switch (achievement.criteria.type) {
          case 'streak':
            shouldUnlock = userProgress.streak >= achievement.criteria.value;
            break;
          case 'level':
            shouldUnlock = userProgress.level >= achievement.criteria.value;
            break;
          case 'lessons':
            shouldUnlock = userProgress.completedLessons >= achievement.criteria.value;
            break;
        }
        
        if (shouldUnlock) {
          db.userAchievements.push({
            userId,
            achievementId: achievement.id,
            unlockedAt: new Date().toISOString(),
            level: 1
          });
          
          // Award rewards
          userProgress.xp += achievement.xpReward;
          userProgress.coins += achievement.coinReward;
          
          // Create notification
          db.notifications.push({
            id: `notif_${Date.now()}`,
            userId,
            type: 'achievement',
            title: 'Nowa odznaka!',
            message: `ZdobyÅ‚eÅ› odznakÄ™ "${achievement.name}"!`,
            data: { achievementId: achievement.id },
            createdAt: new Date().toISOString(),
            readAt: null
          });
          
          unlockedAchievements.push(achievement);
        }
      }
    }
    
    this.saveDB(db);
    return unlockedAchievements;
  }

  // ============================================
  // COMPETITION ENDPOINTS
  // ============================================

  async getCompetitions() {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.competitions.filter(c => c.status === 'active');
  }

  async joinCompetition(userId, competitionId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const competition = db.competitions.find(c => c.id === competitionId);
    if (!competition) {
      throw new Error('Competition not found');
    }
    
    const existingParticipant = db.competitionParticipants.find(
      cp => cp.userId === userId && cp.competitionId === competitionId
    );
    
    if (existingParticipant) {
      throw new Error('Already participating');
    }
    
    const participant = {
      competitionId,
      userId,
      score: 0,
      rank: null,
      attempts: 0,
      bestTime: null,
      joinedAt: new Date().toISOString()
    };
    
    db.competitionParticipants.push(participant);
    this.saveDB(db);
    
    return participant;
  }

  async getLeaderboard(type = 'weekly') {
    await this.simulateDelay();
    const db = this.getDB();
    
    const leaderboard = db.leaderboard.sort((a, b) => {
      switch (type) {
        case 'weekly':
          return b.weeklyXP - a.weeklyXP;
        case 'monthly':
          return b.monthlyXP - a.monthlyXP;
        case 'allTime':
          return b.allTimeXP - a.allTimeXP;
        default:
          return 0;
      }
    });
    
    // Add user details
    return leaderboard.map(entry => {
      const user = db.users.find(u => u.id === entry.userId);
      return {
        ...entry,
        name: user?.name,
        avatar: user?.avatar
      };
    });
  }

  // ============================================
  // SHOP ENDPOINTS
  // ============================================

  async getShopItems() {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.shopItems.filter(item => item.isActive);
  }

  async purchaseItem(userId, itemId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const item = db.shopItems.find(i => i.id === itemId);
    if (!item) {
      throw new Error('Item not found');
    }
    
    const userProgress = db.userProgress.find(p => p.userId === userId);
    
    // Check currency
    if (item.currency === 'coins' && userProgress.coins < item.price) {
      throw new Error('Insufficient coins');
    }
    if (item.currency === 'gems' && userProgress.gems < item.price) {
      throw new Error('Insufficient gems');
    }
    
    // Deduct currency
    if (item.currency === 'coins') {
      userProgress.coins -= item.price;
    } else {
      userProgress.gems -= item.price;
    }
    
    // Add to inventory
    let inventoryItem = db.userInventory.find(
      inv => inv.userId === userId && inv.itemId === itemId
    );
    
    if (inventoryItem) {
      inventoryItem.quantity += 1;
    } else {
      db.userInventory.push({
        userId,
        itemId,
        quantity: 1,
        purchasedAt: new Date().toISOString(),
        expiresAt: item.duration ? new Date(Date.now() + item.duration * 86400000).toISOString() : null
      });
    }
    
    this.saveDB(db);
    
    return {
      success: true,
      newBalance: {
        coins: userProgress.coins,
        gems: userProgress.gems
      }
    };
  }

  async getUserInventory(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const inventory = db.userInventory.filter(inv => inv.userId === userId);
    
    return inventory.map(inv => {
      const item = db.shopItems.find(i => i.id === inv.itemId);
      return {
        ...inv,
        item
      };
    });
  }

  async useItem(userId, itemId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const inventoryItem = db.userInventory.find(
      inv => inv.userId === userId && inv.itemId === itemId && inv.quantity > 0
    );
    
    if (!inventoryItem) {
      throw new Error('Item not found in inventory');
    }
    
    const item = db.shopItems.find(i => i.id === itemId);
    
    // Apply item effect
    const userProgress = db.userProgress.find(p => p.userId === userId);
    
    switch (item.type) {
      case 'boost':
        // In real app, set boost expiration time
        userProgress.activeBoosts = userProgress.activeBoosts || [];
        userProgress.activeBoosts.push({
          type: 'xp_multiplier',
          value: 2,
          expiresAt: new Date(Date.now() + item.duration * 60000).toISOString()
        });
        break;
      case 'protection':
        // Streak freeze
        userProgress.streakFreezeActive = true;
        userProgress.streakFreezeExpires = new Date(Date.now() + 86400000).toISOString();
        break;
    }
    
    // Reduce quantity
    inventoryItem.quantity -= 1;
    
    this.saveDB(db);
    
    return {
      success: true,
      effect: item.type,
      duration: item.duration
    };
  }

  // ============================================
  // SOCIAL ENDPOINTS
  // ============================================

  async getFriends(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const friendships = db.friendships.filter(
      f => (f.userId1 === userId || f.userId2 === userId) && f.status === 'accepted'
    );
    
    const friendIds = friendships.map(f => 
      f.userId1 === userId ? f.userId2 : f.userId1
    );
    
    const friends = friendIds.map(friendId => {
      const user = db.users.find(u => u.id === friendId);
      const progress = db.userProgress.find(p => p.userId === friendId);
      
      return {
        id: user.id,
        name: user.name,
        avatar: user.avatar,
        level: progress?.level,
        xp: progress?.xp,
        streak: progress?.streak,
        isOnline: Math.random() > 0.5 // Simulate online status
      };
    });
    
    return friends;
  }

  async sendFriendRequest(userId, friendEmail) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const friend = db.users.find(u => u.email === friendEmail);
    if (!friend) {
      throw new Error('User not found');
    }
    
    if (friend.id === userId) {
      throw new Error('Cannot add yourself as friend');
    }
    
    // Check if friendship already exists
    const existingFriendship = db.friendships.find(
      f => (f.userId1 === userId && f.userId2 === friend.id) ||
           (f.userId1 === friend.id && f.userId2 === userId)
    );
    
    if (existingFriendship) {
      throw new Error('Friendship already exists');
    }
    
    // Create friend request
    const friendship = {
      userId1: userId,
      userId2: friend.id,
      status: 'pending',
      createdAt: new Date().toISOString()
    };
    
    db.friendships.push(friendship);
    
    // Create notification for friend
    db.notifications.push({
      id: `notif_${Date.now()}`,
      userId: friend.id,
      type: 'friend_request',
      title: 'Nowe zaproszenie do znajomych',
      message: `${db.users.find(u => u.id === userId).name} wysÅ‚aÅ‚ Ci zaproszenie`,
      data: { fromUserId: userId },
      createdAt: new Date().toISOString(),
      readAt: null
    });
    
    this.saveDB(db);
    return friendship;
  }

  // ============================================
  // NOTIFICATIONS ENDPOINTS
  // ============================================

  async getNotifications(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    return db.notifications
      .filter(n => n.userId === userId)
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  }

  async markNotificationAsRead(userId, notificationId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const notification = db.notifications.find(
      n => n.id === notificationId && n.userId === userId
    );
    
    if (!notification) {
      throw new Error('Notification not found');
    }
    
    notification.readAt = new Date().toISOString();
    this.saveDB(db);
    
    return notification;
  }

  async markAllNotificationsAsRead(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    db.notifications
      .filter(n => n.userId === userId && !n.readAt)
      .forEach(n => {
        n.readAt = new Date().toISOString();
      });
    
    this.saveDB(db);
    return { success: true };
  }

  // ============================================
  // ANALYTICS ENDPOINTS
  // ============================================

  async getUserStats(userId) {
    await this.simulateDelay();
    const db = this.getDB();
    
    const progress = db.userProgress.find(p => p.userId === userId);
    const sessions = db.studySessions.filter(s => s.userId === userId);
    const achievements = db.userAchievements.filter(ua => ua.userId === userId);
    
    // Calculate stats
    const last7Days = new Date();
    last7Days.setDate(last7Days.getDate() - 7);
    
    const recentSessions = sessions.filter(
      s => new Date(s.startedAt) > last7Days
    );
    
    const stats = {
      totalXP: progress.xp + (progress.level - 1) * progress.xpToNextLevel,
      totalLessons: progress.completedLessons,
      totalTime: progress.totalStudyTime,
      currentStreak: progress.streak,
      longestStreak: Math.max(progress.streak, 15), // Mock data
      achievementsUnlocked: achievements.length,
      averageSessionTime: sessions.length ? 
        Math.round(sessions.reduce((acc, s) => {
          const duration = (new Date(s.endedAt) - new Date(s.startedAt)) / 60000;
          return acc + duration;
        }, 0) / sessions.length) : 0,
      weeklyActivity: {
        monday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 1).length,
        tuesday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 2).length,
        wednesday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 3).length,
        thursday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 4).length,
        friday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 5).length,
        saturday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 6).length,
        sunday: recentSessions.filter(s => new Date(s.startedAt).getDay() === 0).length
      },
      progressByPath: {}
    };
    
    // Calculate progress by path
    const userStageProgress = db.userStageProgress.filter(sp => sp.userId === userId);
    for (const path of db.paths) {
      const pathStages = db.stages.filter(s => s.pathId === path.id);
      const completedStages = userStageProgress.filter(
        sp => sp.status === 'completed' && 
        pathStages.some(ps => ps.id === sp.stageId)
      ).length;
      
      stats.progressByPath[path.id] = {
        name: path.name,
        progress: pathStages.length ? Math.round((completedStages / pathStages.length) * 100) : 0
      };
    }
    
    return stats;
  }
}

// ============================================
// BUSINESS LOGIC LAYER
// ============================================

class PathFinderService {
  constructor() {
    this.api = new MockAPI();
    this.currentUser = null;
    this.token = localStorage.getItem('authToken');
  }

  // ============================================
  // AUTHENTICATION
  // ============================================

  async login(email, password) {
    try {
      const response = await this.api.login(email, password);
      this.token = response.token;
      this.currentUser = response.user;
      localStorage.setItem('authToken', this.token);
      return response;
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }

  async register(email, password, name) {
    try {
      const response = await this.api.register(email, password, name);
      this.token = response.token;
      this.currentUser = response.user;
      localStorage.setItem('authToken', this.token);
      return response;
    } catch (error) {
      console.error('Registration failed:', error);
      throw error;
    }
  }

  logout() {
    this.token = null;
    this.currentUser = null;
    localStorage.removeItem('authToken');
  }

  isAuthenticated() {
    if (!this.token) return false;
    
    try {
      const payload = JSON.parse(atob(this.token));
      return payload.exp > Date.now();
    } catch {
      return false;
    }
  }

  // ============================================
  // LEARNING MANAGEMENT
  // ============================================

  async startLearningPath(pathId) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const progress = await this.api.getUserProgress(this.currentUser.id);
    progress.currentPathId = pathId;
    
    return await this.api.updateUserProgress(this.currentUser.id, progress);
  }

  async completeLesson(lessonId) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const result = await this.api.completeLesson(this.currentUser.id, lessonId);
    
    // Check for new achievements
    const newAchievements = await this.api.checkAndUnlockAchievements(this.currentUser.id);
    
    // Update daily challenges
    const challenges = await this.api.getDailyChallenges(this.currentUser.id);
    for (const challenge of challenges) {
      if (challenge.type === 'lessons' && !challenge.completed) {
        await this.api.updateChallengeProgress(
          this.currentUser.id,
          challenge.id,
          challenge.progress + 1
        );
      }
      if (challenge.type === 'xp' && !challenge.completed) {
        await this.api.updateChallengeProgress(
          this.currentUser.id,
          challenge.id,
          challenge.progress + result.xpEarned
        );
      }
    }
    
    return {
      ...result,
      newAchievements
    };
  }

  async getRecommendedPath() {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const progress = await this.api.getUserProgress(this.currentUser.id);
    const paths = await this.api.getPaths();
    const userStats = await this.api.getUserStats(this.currentUser.id);
    
    // Simple recommendation algorithm
    let recommendedPath = null;
    let maxScore = 0;
    
    for (const path of paths) {
      let score = 0;
      
      // Check if user has prerequisites
      if (!path.requirements.length || 
          path.requirements.every(req => userStats.progressByPath[req]?.progress >= 80)) {
        score += 50;
      }
      
      // Prefer paths matching user's current level
      if (path.difficulty === 'intermediate' && progress.level >= 10 && progress.level < 30) {
        score += 30;
      } else if (path.difficulty === 'advanced' && progress.level >= 30) {
        score += 30;
      } else if (path.difficulty === 'beginner' && progress.level < 10) {
        score += 30;
      }
      
      // Prefer unstarted or incomplete paths
      const pathProgress = userStats.progressByPath[path.id]?.progress || 0;
      if (pathProgress > 0 && pathProgress < 100) {
        score += 40; // Encourage completion
      } else if (pathProgress === 0) {
        score += 20; // New paths are good too
      }
      
      if (score > maxScore) {
        maxScore = score;
        recommendedPath = path;
      }
    }
    
    return recommendedPath;
  }

  // ============================================
  // GAMIFICATION
  // ============================================

  async updateStreak() {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const progress = await this.api.getUserProgress(this.currentUser.id);
    const lastActivity = new Date(progress.lastActivityDate);
    const today = new Date();
    
    // Check if it's a new day
    if (lastActivity.toDateString() !== today.toDateString()) {
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (lastActivity.toDateString() === yesterday.toDateString()) {
        // Continue streak
        progress.streak += 1;
      } else if (!progress.streakFreezeActive) {
        // Break streak
        progress.streak = 1;
      } else {
        // Use streak freeze
        progress.streakFreezeActive = false;
      }
      
      await this.api.updateUserProgress(this.currentUser.id, progress);
      
      // Check for streak achievements
      await this.api.checkAndUnlockAchievements(this.currentUser.id);
    }
    
    return progress.streak;
  }

  async calculateXPWithBoosts(baseXP) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const progress = await this.api.getUserProgress(this.currentUser.id);
    let multiplier = 1;
    
    if (progress.activeBoosts) {
      const now = new Date();
      progress.activeBoosts = progress.activeBoosts.filter(boost => {
        if (new Date(boost.expiresAt) > now) {
          if (boost.type === 'xp_multiplier') {
            multiplier *= boost.value;
          }
          return true;
        }
        return false;
      });
      
      // Clean up expired boosts
      await this.api.updateUserProgress(this.currentUser.id, progress);
    }
    
    return Math.floor(baseXP * multiplier);
  }

  // ============================================
  // COMPETITION & SOCIAL
  // ============================================

  async joinCompetition(competitionId) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    return await this.api.joinCompetition(this.currentUser.id, competitionId);
  }

  async inviteFriend(email) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    return await this.api.sendFriendRequest(this.currentUser.id, email);
  }

  async getActivityFeed() {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const friends = await this.api.getFriends(this.currentUser.id);
    const notifications = await this.api.getNotifications(this.currentUser.id);
    
    // Combine and sort by date
    const feed = [
      ...notifications.map(n => ({ type: 'notification', ...n })),
      // In real app, fetch friend activities
    ].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    return feed.slice(0, 20); // Return latest 20 items
  }

  // ============================================
  // ANALYTICS & INSIGHTS
  // ============================================

  async getLearningInsights() {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const stats = await this.api.getUserStats(this.currentUser.id);
    
    const insights = {
      strengths: [],
      improvements: [],
      recommendations: []
    };
    
    // Analyze strengths
    if (stats.currentStreak >= 7) {
      insights.strengths.push({
        title: 'Konsekwentny uczeÅ„',
        description: `Utrzymujesz seriÄ™ ${stats.currentStreak} dni!`
      });
    }
    
    if (stats.averageSessionTime >= 30) {
      insights.strengths.push({
        title: 'Skupiony na nauce',
        description: 'Twoje sesje sÄ… dÅ‚ugie i produktywne'
      });
    }
    
    // Identify areas for improvement
    const weeklyTotal = Object.values(stats.weeklyActivity).reduce((a, b) => a + b, 0);
    if (weeklyTotal < 5) {
      insights.improvements.push({
        title: 'ZwiÄ™ksz czÄ™stotliwoÅ›Ä‡',
        description: 'Staraj siÄ™ uczyÄ‡ przynajmniej 5 razy w tygodniu'
      });
    }
    
    // Generate recommendations
    if (stats.totalTime < 60) {
      insights.recommendations.push({
        title: 'WydÅ‚uÅ¼ sesje',
        description: 'SprÃ³buj uczyÄ‡ siÄ™ przez co najmniej 15 minut dziennie'
      });
    }
    
    const recommendedPath = await this.getRecommendedPath();
    if (recommendedPath) {
      insights.recommendations.push({
        title: 'Polecana Å›cieÅ¼ka',
        description: `Rozpocznij naukÄ™: ${recommendedPath.name}`,
        action: () => this.startLearningPath(recommendedPath.id)
      });
    }
    
    return insights;
  }

  async getPredictedCompletionDate(pathId) {
    if (!this.currentUser) throw new Error('Not authenticated');
    
    const stats = await this.api.getUserStats(this.currentUser.id);
    const pathDetails = await this.api.getPathDetails(pathId);
    
    // Calculate based on current pace
    const avgLessonsPerDay = stats.totalLessons / 30; // Last 30 days
    const totalLessons = pathDetails.stages.reduce((acc, stage) => {
      return acc + stage.lessons.length;
    }, 0);
    
    const remainingLessons = totalLessons - (stats.progressByPath[pathId]?.progress || 0) / 100 * totalLessons;
    const daysToComplete = Math.ceil(remainingLessons / Math.max(avgLessonsPerDay, 0.5));
    
    const completionDate = new Date();
    completionDate.setDate(completionDate.getDate() + daysToComplete);
    
    return {
      date: completionDate,
      daysRemaining: daysToComplete,
      confidence: avgLessonsPerDay > 1 ? 'high' : avgLessonsPerDay > 0.5 ? 'medium' : 'low'
    };
  }
}

// ============================================
// EXPORT
// ============================================

// Export for use in React component
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { MockAPI, PathFinderService };
}

// For browser usage
if (typeof window !== 'undefined') {
  window.PathFinderAPI = MockAPI;
  window.PathFinderService = PathFinderService;
}
